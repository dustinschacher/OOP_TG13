import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class KMeans {
    static class Point {
        double x, y;

        Point(double x, double y) {
            this.x = x;
            this.y = y;
        }

        double distance(Point other) {
            return Math.sqrt(Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2));
        }

        @Override
        public String toString() {
            return "(" + x + ", " + y + ")";
        }
    }

    public static void main(String[] args) {
        // Beispiel-Datenpunkte
        List<Point> points = List.of(
            new Point(1.0, 1.0),
            new Point(1.5, 2.0),
            new Point(3.0, 4.0),
            new Point(5.0, 7.0),
            new Point(3.5, 5.0),
            new Point(4.5, 5.0),
            new Point(3.5, 4.5)
        );

        int k = 2; // Anzahl der Cluster
        int maxIterations = 100;

        List<List<Point>> clusters = kMeans(points, k, maxIterations);

        // Ergebnisse ausgeben
        for (int i = 0; i < clusters.size(); i++) {
            System.out.println("Cluster " + (i + 1) + ": " + clusters.get(i));
        }
    }

    public static List<List<Point>> kMeans(List<Point> points, int k, int maxIterations) {
        List<Point> centroids = initializeCentroids(points, k);
        List<List<Point>> clusters = new ArrayList<>();

        for (int iteration = 0; iteration < maxIterations; iteration++) {
            // Erstellen neuer Cluster
            clusters.clear();
            for (int i = 0; i < k; i++) {
                clusters.add(new ArrayList<>());
            }

            // Punkte den nächsten Zentren zuweisen
            for (Point point : points) {
                int closestCentroid = getClosestCentroid(point, centroids);
                clusters.get(closestCentroid).add(point);
            }

            // Zentren aktualisieren
            List<Point> newCentroids = new ArrayList<>();
            for (List<Point> cluster : clusters) {
                newCentroids.add(calculateCentroid(cluster));
            }

            // Überprüfen, ob die Zentren stabil bleiben
            if (centroids.equals(newCentroids)) {
                break;
            }
            centroids = newCentroids;
        }

        return clusters;
    }

    private static List<Point> initializeCentroids(List<Point> points, int k) {
        List<Point> centroids = new ArrayList<>();
        Random random = new Random();
        for (int i = 0; i < k; i++) {
            centroids.add(points.get(random.nextInt(points.size())));
        }
        return centroids;
    }

    private static int getClosestCentroid(Point point, List<Point> centroids) {
        int closest = 0;
        double minDistance = point.distance(centroids.get(0));
        for (int i = 1; i < centroids.size(); i++) {
            double distance = point.distance(centroids.get(i));
            if (distance < minDistance) {
                closest = i;
                minDistance = distance;
            }
        }
        return closest;
    }

    private static Point calculateCentroid(List<Point> cluster) {
        double sumX = 0, sumY = 0;
        for (Point point : cluster) {
            sumX += point.x;
            sumY += point.y;
        }
        return new Point(sumX / cluster.size(), sumY / cluster.size());
    }
}
